================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-30T20:31:03.561Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  ios/
    Flutter/
      AppFrameworkInfo.plist
    Runner/
      AppDelegate.swift
      GoogleService-Info.plist
      Info.plist
    Podfile
  lib/
    about_screen.dart
    app_state.dart
    guidelines_screen.dart
    home_screen.dart
    login_screen.dart
    main.dart
    post_card.dart
    post_detail_screen.dart
    post_screen.dart
    privacy_policy_screen.dart
    profile_screen.dart
    scuttlebutt_app.dart
    settings_screen.dart
    zone_selection_screen.dart
  pubspec.yaml
functions/
  index.js
firebase.json
wm-db.txt

================================================================
Repository Files
================================================================

================
File: app/ios/Flutter/AppFrameworkInfo.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>

================
File: app/ios/Runner/AppDelegate.swift
================
import UIKit
import Flutter

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

================
File: app/ios/Runner/GoogleService-Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CLIENT_ID</key>
	<string>836223047567-16jbink7cop8u5g0jbvi84l35g3obr7c.apps.googleusercontent.com</string>
	<key>REVERSED_CLIENT_ID</key>
	<string>com.googleusercontent.apps.836223047567-16jbink7cop8u5g0jbvi84l35g3obr7c</string>
	<key>API_KEY</key>
	<string>AIzaSyD2ViYs-t-WxIzSFm9BOeQEQiT5JkC6xPY</string>
	<key>GCM_SENDER_ID</key>
	<string>836223047567</string>
	<key>PLIST_VERSION</key>
	<string>1</string>
	<key>BUNDLE_ID</key>
	<string>com.park.scuttle</string>
	<key>PROJECT_ID</key>
	<string>scuttlebutt-a48e6</string>
	<key>STORAGE_BUCKET</key>
	<string>scuttlebutt-a48e6.appspot.com</string>
	<key>IS_ADS_ENABLED</key>
	<false></false>
	<key>IS_ANALYTICS_ENABLED</key>
	<false></false>
	<key>IS_APPINVITE_ENABLED</key>
	<true></true>
	<key>IS_GCM_ENABLED</key>
	<true></true>
	<key>IS_SIGNIN_ENABLED</key>
	<true></true>
	<key>GOOGLE_APP_ID</key>
	<string>1:836223047567:ios:c7bfc6403d597f75e51dfa</string>
</dict>
</plist>

================
File: app/ios/Runner/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CADisableMinimumFrameDurationOnPhone</key>
    <true/>
    <key>CFBundleDevelopmentRegion</key>
    <string>$(DEVELOPMENT_LANGUAGE)</string>
    <key>CFBundleDisplayName</key>
    <string>Scuttle</string>
    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>Scuttle</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleShortVersionString</key>
    <string>$(FLUTTER_BUILD_NAME)</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleURLTypes</key>
    <array>
        <dict>
            <key>CFBundleTypeRole</key>
            <string>Editor</string>
            <key>CFBundleURLName</key>
            <string>com.googleusercontent.apps.836223047567-flvb9gpmrb10jblcs2jepl2annqooek3</string>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>com.googleusercontent.apps.836223047567-16jbink7cop8u5g0jbvi84l35g3obr7c</string>
            </array>
        </dict>
        <dict>
            <key>CFBundleTypeRole</key>
            <string>Editor</string>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>com.park.scuttle</string>
            </array>
        </dict>
    </array>
    <key>CFBundleVersion</key>
    <string>$(FLUTTER_BUILD_NUMBER)</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>NSLocationWhenInUseUsageDescription</key>
    <string>This app needs access to location to recommend your command zone.</string>
    <key>NSLocationAlwaysUsageDescription</key>
    <string>This app needs access to location to recommend your command zone.</string>
    <key>NSPhotoLibraryUsageDescription</key>
    <string>Scuttle needs access to your photo library to allow you to select images for your posts.</string>
    <key>NSCameraUsageDescription</key>
    <string>Scuttle needs access to your camera to allow you to take photos for your posts.</string>
    <key>UILaunchStoryboardName</key>
    <string>LaunchScreen</string>
    <key>UIMainStoryboardFile</key>
    <string>Main</string>
    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
        <string>UIInterfaceOrientationLandscapeLeft</string>
        <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
    <key>UISupportedInterfaceOrientations~ipad</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
        <string>UIInterfaceOrientationPortraitUpsideDown</string>
        <string>UIInterfaceOrientationLandscapeLeft</string>
        <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
    <key>UIApplicationSupportsIndirectInputEvents</key>
    <true/>
</dict>
</plist>

================
File: app/ios/Podfile
================
# Google Maps requires iOS 13: https://developers.google.com/maps/documentation/ios-sdk/overview#supported_platforms
platform :ios, '14.0'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure flutter pub get is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Generated.xcconfig, then run flutter pub get"
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  use_frameworks!
  use_modular_headers!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)
  end
end

================
File: app/lib/about_screen.dart
================
import 'package:flutter/material.dart';

class AboutScreen extends StatelessWidget {
  const AboutScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Settings'),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Welcome to Scuttle',
              style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            _buildParagraph(
              'Scuttle is an anonymous feed-based social app for service members to engage with other service members near them. As a Navy veteran, I focused on the Navy for this version.',
            ),
            SizedBox(height: 16),
            Text(
              'There are eight "zones," each with a generous radius:',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            Text(
              '‚Ä¢ Norfolk\n‚Ä¢ San Diego\n‚Ä¢ Jacksonville\n‚Ä¢ Pensacola\n‚Ä¢ PNW\n‚Ä¢ Japan\n‚Ä¢ Hawaii\n‚Ä¢ DMV',
              style: TextStyle(fontSize: 18),
            ),
            SizedBox(height: 16),
            _buildParagraph(
              'I initially considered setting zones at the command level, but decided against it due to OPSEC. All users\' military status is verified through ID.me.',
            ),
            SizedBox(height: 16),
            _buildParagraph(
              'Blind exists for companies, Fizz for colleges, and while Yik Yak is no longer as widely used, Scuttle aims to fill a similar niche for service members. Whether you\'re temporarily on TDY and don\'t know anyone, or you want to connect with service members near you, Scuttle is here to help.',
            ),
            SizedBox(height: 16),
            _buildParagraph(
              'The main difference between the "All Navy" feed and the Navy subreddit is that everyone on Scuttle is a verified service member.',
            ),
            SizedBox(height: 16),
            _buildParagraph(
              'The app is still in development and may have some bugs. Feedback and comments are welcome. Please feel free to contact jpslvtr@gmail.com.\n',
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildParagraph(String text) {
    return Text(
      text,
      style: TextStyle(fontSize: 18),
    );
  }
}

================
File: app/lib/app_state.dart
================
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:geolocator/geolocator.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'dart:io';

class AppState extends ChangeNotifier {
  String? userId;
  String? command;
  String? userName;
  List<String> savedPosts = [];
  Map<String, int> userVotes = {};
  Map<String, int> userCommentVotes = {};
  String currentFeed = 'All Navy';
  int userPoints = 0;
  Position? userLocation;
  bool isLocationDenied = false;
  bool isOutOfZone = false;
  bool isNewUser = true;
  bool isLocationPermissionChecked = false;
  bool isIdMeVerified = false;

  static const Map<String, Map<String, dynamic>> zones = {
    // 'Sample Zone': {
    //   'center': {'lat': 37.7749, 'lng': -122.4194},
    //   'radius': 80467
    // },
    'Norfolk': {
      'center': {'lat': 36.8508, 'lng': -76.2859},
      'radius': 120700
    },
    'San Diego': {
      'center': {'lat': 32.7157, 'lng': -117.1611},
      'radius': 160934
    },
    'Jacksonville': {
      'center': {'lat': 30.3322, 'lng': -81.6557},
      'radius': 120700
    },
    'Pensacola': {
      'center': {'lat': 30.4213, 'lng': -87.2169},
      'radius': 160934
    },
    'Pacific Northwest': {
      'center': {'lat': 47.6062, 'lng': -122.3321},
      'radius': 160934
    },
    'Japan': {
      'center': {'lat': 35.6762, 'lng': 139.6503},
      'radius': 804672
    },
    'Hawaii': {
      'center': {'lat': 21.3069, 'lng': -157.8583},
      'radius': 321869
    },
    'National Capital Region': {
      'center': {'lat': 38.9072, 'lng': -77.0369},
      'radius': 160934
    },
  };

  AppState({this.userId, this.command, this.userName});

  Future<String?> uploadImage(File image) async {
    if (userId == null) return null;

    try {
      final ref = FirebaseStorage.instance
          .ref()
          .child('post_images')
          .child('${DateTime.now().toIso8601String()}_$userId.jpg');

      await ref.putFile(image);
      final url = await ref.getDownloadURL();
      return url;
    } catch (e) {
      print('Error uploading image: $e');
      return null;
    }
  }

  Future<void> initializeUser(String uid) async {
    userId = uid;
    try {
      DocumentSnapshot userDoc =
          await FirebaseFirestore.instance.collection('users').doc(uid).get();
      if (userDoc.exists) {
        Map<String, dynamic> userData = userDoc.data() as Map<String, dynamic>;
        command = userData['command'] as String?;
        userName = userData['userName'] as String?;
        savedPosts = List<String>.from(userData['savedPosts'] ?? []);
        userVotes = Map<String, int>.from(userData['votes'] ?? {});
        userCommentVotes =
            Map<String, int>.from(userData['commentVotes'] ?? {});
        userPoints = userData['points'] as int? ?? 0;
        isIdMeVerified = userData['isIdMeVerified'] as bool? ?? false;
        isNewUser = false;

        // Check if the user is an App Store reviewer
        if (userData['isAppStoreReviewer'] == true) {
          command = 'All Navy';
          currentFeed = 'All Navy';
        }
      } else {
        await createUserDocument(uid);
      }
      await recalculateUserPoints();
    } catch (e) {
      print('Error initializing user: $e');
      await createUserDocument(uid);
    }
    notifyListeners();
  }

  Future<void> createUserDocument(String uid) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        throw Exception('No authenticated user found');
      }

      bool isAppStoreReviewer = user.email == 'scouttestreview@gmail.com';

      await FirebaseFirestore.instance.collection('users').doc(uid).set({
        'email': user.email,
        'createdAt': FieldValue.serverTimestamp(),
        'profileEmoji': isAppStoreReviewer ? 'üßë‚Äçüíª' : 'üôÇ',
        'savedPosts': [],
        'userName': isAppStoreReviewer ? '@appstorereview' : '',
        'votes': {},
        'commentVotes': {},
        'points': 0,
        'command': isAppStoreReviewer ? 'All Navy' : null,
        'isIdMeVerified': false,
        'isAppStoreReviewer': isAppStoreReviewer,
      }, SetOptions(merge: true));

      isNewUser = true;
      if (isAppStoreReviewer) {
        command = 'All Navy';
        currentFeed = 'All Navy';
      }
      notifyListeners();
    } catch (e) {
      print('Error creating user document: $e');
      throw e;
    }
  }

  Future<void> setIdMeVerified(bool verified) async {
    if (userId == null) return;

    try {
      await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .update({'isIdMeVerified': verified});
      isIdMeVerified = verified;
      notifyListeners();
    } catch (e) {
      print('Error updating ID.me verification status: $e');
    }
  }

  Future<void> updateUserPoints(int delta) async {
    if (userId == null) return;

    try {
      await FirebaseFirestore.instance.runTransaction((transaction) async {
        DocumentReference userRef =
            FirebaseFirestore.instance.collection('users').doc(userId);
        DocumentSnapshot userDoc = await transaction.get(userRef);

        if (!userDoc.exists) {
          throw Exception('User document does not exist!');
        }

        int currentPoints = userDoc.get('points') as int? ?? 0;
        int newPoints = (currentPoints + delta).clamp(0, 999);

        transaction.update(userRef, {'points': newPoints});

        userPoints = newPoints;
      });
      notifyListeners();
    } catch (e) {
      print('Error updating user points: $e');
    }
  }

  Future<void> recalculateUserPoints() async {
    if (userId == null) return;

    try {
      int totalPoints = 0;

      // Calculate points from posts (1 point per post)
      QuerySnapshot postsDocs = await FirebaseFirestore.instance
          .collection('posts')
          .where('userId', isEqualTo: userId)
          .get();
      totalPoints += postsDocs.docs.length;

      // Calculate points from comments (1 point per comment)
      QuerySnapshot commentsDocs = await FirebaseFirestore.instance
          .collection('comments')
          .where('userId', isEqualTo: userId)
          .get();
      totalPoints += commentsDocs.docs.length;

      // Calculate points from post upvotes (1 point per upvote)
      for (var post in postsDocs.docs) {
        int postPoints =
            (post.data() as Map<String, dynamic>)['points'] as int? ?? 0;
        totalPoints += postPoints.clamp(0, 5); // Cap points per post at 5
      }

      // Calculate points from comment upvotes (1 point per upvote)
      for (var comment in commentsDocs.docs) {
        int commentPoints =
            (comment.data() as Map<String, dynamic>)['points'] as int? ?? 0;
        totalPoints += commentPoints.clamp(0, 3); // Cap points per comment at 3
      }

      // Cap total points at 999
      totalPoints = totalPoints.clamp(0, 999);

      // Set the calculated points
      await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .update({'points': totalPoints});

      userPoints = totalPoints;
      notifyListeners();
    } catch (e) {
      print('Error recalculating user points: $e');
    }
  }

  Future<void> calculateAndSetInitialPoints() async {
    if (userId == null) return;

    try {
      int totalPoints = 0;

      // Calculate points from posts
      QuerySnapshot postsDocs = await FirebaseFirestore.instance
          .collection('posts')
          .where('userId', isEqualTo: userId)
          .get();
      totalPoints += postsDocs.docs.length * 2;

      // Calculate points from comments
      QuerySnapshot commentsDocs = await FirebaseFirestore.instance
          .collection('comments')
          .where('userId', isEqualTo: userId)
          .get();
      totalPoints += commentsDocs.docs.length;

      // Calculate points from post votes
      for (var post in postsDocs.docs) {
        totalPoints +=
            (post.data() as Map<String, dynamic>)['points'] as int? ?? 0;
      }

      // Calculate points from comment votes
      for (var comment in commentsDocs.docs) {
        totalPoints +=
            (comment.data() as Map<String, dynamic>)['points'] as int? ?? 0;
      }

      // Set the calculated points
      await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .update({'points': totalPoints});

      userPoints = totalPoints;
      notifyListeners();
    } catch (e) {
      print('Error calculating initial points: $e');
    }
  }
  
  Future<bool> checkUserExists(String uid) async {
    try {
      DocumentSnapshot userDoc =
          await FirebaseFirestore.instance.collection('users').doc(uid).get();
      return userDoc.exists;
    } catch (e) {
      print('Error checking if user exists: $e');
      return false;
    }
  }

  Future<void> setLocationPermissionChecked(bool checked) async {
    isLocationPermissionChecked = checked;
    notifyListeners();
  }

  Future<void> setUserLocation(Position position) async {
    userLocation = position;
    notifyListeners();
  }

  String? getRecommendedZone() {
    if (userLocation == null) return null;

    String? closestZone;
    double minDistance = double.infinity;

    for (var entry in zones.entries) {
      var zone = entry.value;
      var center = zone['center'];
      var zoneRadius = zone['radius'];

      double distance = Geolocator.distanceBetween(
        userLocation!.latitude,
        userLocation!.longitude,
        center['lat'],
        center['lng'],
      );

      if (distance < minDistance && distance <= zoneRadius) {
        minDistance = distance;
        closestZone = entry.key;
      }
    }

    return closestZone;
  }

  Future<void> setUserCommand(String? newCommand) async {
    command = newCommand;
    currentFeed = newCommand ?? 'All Navy';
    isOutOfZone = newCommand == null;
    try {
      await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .update({'command': newCommand});
      notifyListeners();
    } catch (e) {
      print('Error updating user command: $e');
    }
  }

  void setLocationDenied(bool denied) {
    isLocationDenied = denied;
    notifyListeners();
  }

  void setCurrentFeed(String feed) {
    if (feed == 'All Navy' || feed == command) {
      currentFeed = feed;
      notifyListeners();
    }
  }

  List<String> getAvailableFeeds() {
    if (command != null) {
      return ['All Navy', command!];
    } else {
      return ['All Navy'];
    }
  }

  void clearUserData() {
    userId = null;
    command = null;
    userName = null;
    savedPosts.clear();
    userVotes.clear();
    userCommentVotes.clear();
    currentFeed = 'All Navy';
    userPoints = 0;
    notifyListeners();
  }

  Future<bool> isUserNameAvailable(String userName) async {
    if (userName.isEmpty) return true;
    try {
      QuerySnapshot query = await FirebaseFirestore.instance
          .collection('users')
          .where('userName', isEqualTo: userName)
          .get();
      return query.docs.isEmpty;
    } catch (e) {
      print('Error checking username availability: $e');
      return false;
    }
  }

  Stream<QuerySnapshot> getPostsStream(String currentFeed) {
    Query query;
    if (currentFeed == 'All Navy') {
      query = FirebaseFirestore.instance
          .collection('posts')
          .where('feed', isEqualTo: 'All Navy');
    } else {
      query = FirebaseFirestore.instance
          .collection('posts')
          .where('feed', isEqualTo: currentFeed);
    }
    return query.orderBy('timestamp', descending: true).limit(50).snapshots();
  }

  Stream<DocumentSnapshot> getPostStream(String postId) {
    return FirebaseFirestore.instance
        .collection('posts')
        .doc(postId)
        .snapshots();
  }

  Stream<DocumentSnapshot> getCommentStream(String commentId) {
    return FirebaseFirestore.instance
        .collection('comments')
        .doc(commentId)
        .snapshots();
  }

  Future<void> updatePostPoints(String postId, int delta) async {
    if (userId == null) return;

    try {
      await FirebaseFirestore.instance.runTransaction((transaction) async {
        DocumentReference postRef =
            FirebaseFirestore.instance.collection('posts').doc(postId);
        DocumentSnapshot freshPost = await transaction.get(postRef);

        if (!freshPost.exists) {
          throw Exception('Post does not exist!');
        }

        int currentVote = userVotes[postId] ?? 0;
        int newVote;

        if (currentVote == delta) {
          newVote = 0;
          delta = -currentVote;
        } else {
          newVote = delta;
          delta = newVote - currentVote;
        }

        int oldPoints = freshPost.get('points') as int;
        int newPoints = oldPoints + delta;

        // Read user document
        DocumentReference userRef =
            FirebaseFirestore.instance.collection('users').doc(userId);
        DocumentSnapshot userDoc = await transaction.get(userRef);

        // Read post creator document
        String postCreatorId = freshPost.get('userId') as String;
        DocumentReference postCreatorRef =
            FirebaseFirestore.instance.collection('users').doc(postCreatorId);
        DocumentSnapshot postCreatorDoc = await transaction.get(postCreatorRef);

        // Perform all writes after reads
        transaction.update(postRef, {'points': newPoints});
        transaction.update(userRef, {'votes.$postId': newVote});

        // Update post creator's points if the user exists
        if (postCreatorDoc.exists && postCreatorId != userId) {
          int creatorPoints = postCreatorDoc.get('points') as int? ?? 0;
          transaction.update(postCreatorRef, {'points': creatorPoints + delta});
        }

        // Update local state
        userVotes[postId] = newVote;
      });
    } catch (e) {
      print('Error updating post points: $e');
    }
  }

  Future<void> updateCommentPoints(String commentId, int delta) async {
    if (userId == null) return;

    try {
      await FirebaseFirestore.instance.runTransaction((transaction) async {
        DocumentReference commentRef =
            FirebaseFirestore.instance.collection('comments').doc(commentId);
        DocumentSnapshot freshComment = await transaction.get(commentRef);

        if (!freshComment.exists) {
          throw Exception('Comment does not exist!');
        }

        int currentVote = userCommentVotes[commentId] ?? 0;
        int newVote;
        int pointsDelta;

        if (currentVote == delta) {
          // If the user is voting the same way, remove their vote
          newVote = 0;
          pointsDelta = -currentVote;
        } else if (currentVote == 0) {
          // If the user hasn't voted before, add their vote
          newVote = delta;
          pointsDelta = delta;
        } else {
          // If the user is changing their vote, update accordingly
          newVote = delta;
          pointsDelta = delta *
              2; // Multiply by 2 to reverse previous vote and add new vote
        }

        int oldPoints = freshComment.get('points') as int;
        int newPoints = oldPoints + pointsDelta;

        // Perform all reads before writes
        DocumentReference userRef =
            FirebaseFirestore.instance.collection('users').doc(userId);
        DocumentSnapshot userDoc = await transaction.get(userRef);

        String commentCreatorId = freshComment.get('userId') as String;
        DocumentReference commentCreatorRef = FirebaseFirestore.instance
            .collection('users')
            .doc(commentCreatorId);
        DocumentSnapshot commentCreatorDoc =
            await transaction.get(commentCreatorRef);

        // Now perform all writes
        transaction.update(commentRef, {'points': newPoints});
        transaction.update(userRef, {'commentVotes.$commentId': newVote});

        // Update comment creator's points if the user exists and it's not the current user
        if (commentCreatorDoc.exists && commentCreatorId != userId) {
          int creatorPoints = commentCreatorDoc.get('points') as int? ?? 0;
          transaction.update(
              commentCreatorRef, {'points': creatorPoints + pointsDelta});
        }

        // Update local state
        userCommentVotes[commentId] = newVote;
      });
    } catch (e) {
      print('Error updating comment points: $e');
    }
  }

  Future<void> createPost(String title, String content, String feed,
      {File? image}) async {
    if (userId == null) return;

    String postFeed = feed == 'All Navy' ? 'All Navy' : command ?? '';

    DocumentSnapshot userDoc =
        await FirebaseFirestore.instance.collection('users').doc(userId).get();

    Map<String, dynamic> userData = userDoc.data() as Map<String, dynamic>;
    String currentUserName = userData['userName'] as String? ?? '';
    String currentProfileEmoji = userData['profileEmoji'] as String? ?? 'üôÇ';

    String? imageUrl;
    if (image != null) {
      imageUrl = await uploadImage(image);
    }

    await FirebaseFirestore.instance.collection('posts').add({
      'title': title,
      'content': content,
      'userId': userId,
      'userName': currentUserName,
      'command': command,
      'feed': postFeed,
      'points': 0,
      'commentCount': 0,
      'timestamp': FieldValue.serverTimestamp(),
      'profileEmoji': currentProfileEmoji,
      'imageUrl': imageUrl, // Include the imageUrl in the post data
    });

    // Award 1 point for creating a post
    await updateUserPoints(1);

    notifyListeners();
  }

  Future<void> createComment(String postId, String content) async {
    if (userId == null) return;

    DocumentSnapshot userDoc =
        await FirebaseFirestore.instance.collection('users').doc(userId).get();

    Map<String, dynamic> userData = userDoc.data() as Map<String, dynamic>;
    String currentUserName = userData['userName'] as String? ?? '';
    String currentProfileEmoji = userData['profileEmoji'] as String? ?? 'üôÇ';

    DocumentReference commentRef =
        await FirebaseFirestore.instance.collection('comments').add({
      'postId': postId,
      'userId': userId,
      'userName': currentUserName,
      'profileEmoji': currentProfileEmoji,
      'content': content,
      'points': 0,
      'timestamp': FieldValue.serverTimestamp(),
    });

    await FirebaseFirestore.instance.collection('posts').doc(postId).update({
      'commentCount': FieldValue.increment(1),
    });

    // Award 1 point for creating a comment
    await updateUserPoints(1);

    notifyListeners();
  }

  Future<void> deleteAccount() async {
    if (userId == null) return;

    try {
      DocumentSnapshot userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .get();

      if (!userDoc.exists) {
        throw Exception('User document does not exist');
      }

      Map<String, dynamic> userData = userDoc.data() as Map<String, dynamic>;
      String? userNameToCheck = userData['userName'] as String?;
      bool hadUsername = userNameToCheck != null && userNameToCheck.isNotEmpty;

      if (hadUsername) {
        await FirebaseFirestore.instance
            .collection('posts')
            .where('userId', isEqualTo: userId)
            .get()
            .then((snapshot) {
          for (DocumentSnapshot doc in snapshot.docs) {
            doc.reference.update({
              'userName': '[deleted]',
              'profileEmoji': 'ü´•',
            });
          }
        });

        await FirebaseFirestore.instance
            .collection('comments')
            .where('userId', isEqualTo: userId)
            .get()
            .then((snapshot) {
          for (DocumentSnapshot doc in snapshot.docs) {
            doc.reference.update({
              'userName': '[deleted]',
              'profileEmoji': 'ü´•',
            });
          }
        });
      }

      await FirebaseFirestore.instance.collection('users').doc(userId).delete();

      await FirebaseAuth.instance.currentUser?.delete();

      clearUserData();
    } catch (e) {
      print('Error deleting account: $e');
      throw e;
    }
  }

  Future<Map<String, dynamic>> getUserProfile() async {
    if (userId == null) return {};

    try {
      DocumentSnapshot userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .get();

      if (!userDoc.exists) {
        await createUserDocument(userId!);
        userDoc = await FirebaseFirestore.instance
            .collection('users')
            .doc(userId)
            .get();
      }

      return userDoc.data() as Map<String, dynamic>;
    } catch (e) {
      print('Error fetching user profile: $e');
      return {};
    }
  }

  Future<void> updateUserProfile(Map<String, dynamic> data) async {
    if (userId == null) return;

    try {
      if (data.containsKey('userName')) {
        String newUserName = data['userName'] as String;
        if (newUserName.toLowerCase() == 'anonymous') {
          print('Error: Username "anonymous" is not allowed');
          return;
        }
        if (newUserName.length > 15) {
          print('Error: Username must be 15 characters or less');
          return;
        }
        if (!(await isUserNameAvailable(newUserName))) {
          print('Error: Username is not available');
          return;
        }

        // Update posts
        QuerySnapshot postsSnapshot = await FirebaseFirestore.instance
            .collection('posts')
            .where('userId', isEqualTo: userId)
            .get();

        WriteBatch batch = FirebaseFirestore.instance.batch();

        for (DocumentSnapshot doc in postsSnapshot.docs) {
          batch.update(doc.reference, {'userName': newUserName});
        }

        // Update comments
        QuerySnapshot commentsSnapshot = await FirebaseFirestore.instance
            .collection('comments')
            .where('userId', isEqualTo: userId)
            .get();

        for (DocumentSnapshot doc in commentsSnapshot.docs) {
          batch.update(doc.reference, {'userName': newUserName});
        }

        // Update user document
        DocumentReference userRef =
            FirebaseFirestore.instance.collection('users').doc(userId);
        batch.update(userRef, data);

        // Commit the batch
        await batch.commit();

        // Update local state
        userName = newUserName;
      } else {
        // If we're not updating the username, just update the user document
        await FirebaseFirestore.instance
            .collection('users')
            .doc(userId)
            .update(data);
      }

      notifyListeners();
    } catch (e) {
      print('Error updating user profile: $e');
    }
  }

  Future<void> deletePost(String postId) async {
    if (userId == null) return;

    try {
      DocumentSnapshot postDoc = await FirebaseFirestore.instance
          .collection('posts')
          .doc(postId)
          .get();

      if (postDoc.exists) {
        Map<String, dynamic> postData = postDoc.data() as Map<String, dynamic>;
        if (postData['userId'] == userId) {
          // Delete the post
          await FirebaseFirestore.instance
              .collection('posts')
              .doc(postId)
              .delete();

          // Delete all comments associated with the post
          QuerySnapshot comments = await FirebaseFirestore.instance
              .collection('comments')
              .where('postId', isEqualTo: postId)
              .get();

          for (DocumentSnapshot commentDoc in comments.docs) {
            await commentDoc.reference.delete();
          }

          // Remove the post from saved posts of all users
          QuerySnapshot usersWithSavedPost = await FirebaseFirestore.instance
              .collection('users')
              .where('savedPosts', arrayContains: postId)
              .get();

          for (DocumentSnapshot userDoc in usersWithSavedPost.docs) {
            List<String> savedPosts = List<String>.from(userDoc['savedPosts']);
            savedPosts.remove(postId);
            await userDoc.reference.update({'savedPosts': savedPosts});
          }

          // Update local state
          if (savedPosts.contains(postId)) {
            savedPosts.remove(postId);
          }

          notifyListeners();
        } else {
          throw Exception('You do not have permission to delete this post');
        }
      } else {
        throw Exception('Post not found');
      }
    } catch (e) {
      print('Error deleting post: $e');
      throw e;
    }
  }

  Future<void> deleteComment(String postId, String commentId) async {
    if (userId == null) return;

    try {
      await FirebaseFirestore.instance
          .collection('comments')
          .doc(commentId)
          .delete();

      await FirebaseFirestore.instance.collection('posts').doc(postId).update({
        'commentCount': FieldValue.increment(-1),
      });

      notifyListeners();
    } catch (e) {
      print('Error deleting comment: $e');
    }
  }

  Future<void> updateProfileEmoji(String emoji) async {
    if (userId == null) return;

    try {
      await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .update({'profileEmoji': emoji});
      notifyListeners();
    } catch (e) {
      print('Error updating profile emoji: $e');
    }
  }

  Future<void> toggleSavedPost(String postId) async {
    if (userId == null) return;

    try {
      DocumentSnapshot postDoc = await FirebaseFirestore.instance
          .collection('posts')
          .doc(postId)
          .get();

      if (postDoc.exists) {
        Map<String, dynamic> postData = postDoc.data() as Map<String, dynamic>;
        if (postData['userId'] == userId) {
          print('Cannot save your own post');
          return;
        }
      }

      if (savedPosts.contains(postId)) {
        savedPosts.remove(postId);
      } else {
        savedPosts.insert(0, postId);
      }

      await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .update({'savedPosts': savedPosts});

      notifyListeners();
    } catch (e) {
      print('Error toggling saved post: $e');
    }
  }

  Future<List<DocumentSnapshot>> getSavedPosts() async {
    if (userId == null) return [];

    try {
      List<DocumentSnapshot> savedPostDocs = [];

      // Use batched reads to fetch all saved posts at once
      final batches = <Future<List<DocumentSnapshot>>>[];
      for (var i = 0; i < savedPosts.length; i += 10) {
        final end = (i + 10 < savedPosts.length) ? i + 10 : savedPosts.length;
        final batch = FirebaseFirestore.instance
            .collection('posts')
            .where(FieldPath.documentId, whereIn: savedPosts.sublist(i, end))
            .get()
            .then((snapshot) => snapshot.docs);
        batches.add(batch);
      }

      final results = await Future.wait(batches);
      for (var batch in results) {
        savedPostDocs.addAll(batch);
      }

      // Sort the posts to match the order in savedPosts
      savedPostDocs.sort((a, b) =>
          savedPosts.indexOf(a.id).compareTo(savedPosts.indexOf(b.id)));

      return savedPostDocs;
    } catch (e) {
      print('Error fetching saved posts: $e');
      return [];
    }
  }

  Future<Map<String, Map<String, dynamic>>> getUsersData(
      List<String> userIds) async {
    final uniqueUserIds = userIds.toSet().toList();
    final Map<String, Map<String, dynamic>> usersData = {};

    try {
      final batches = <Future<List<DocumentSnapshot>>>[];
      for (var i = 0; i < uniqueUserIds.length; i += 10) {
        final end =
            (i + 10 < uniqueUserIds.length) ? i + 10 : uniqueUserIds.length;
        final batch = FirebaseFirestore.instance
            .collection('users')
            .where(FieldPath.documentId, whereIn: uniqueUserIds.sublist(i, end))
            .get()
            .then((snapshot) => snapshot.docs);
        batches.add(batch);
      }

      final results = await Future.wait(batches);
      for (var batch in results) {
        for (var doc in batch) {
          usersData[doc.id] = doc.data() as Map<String, dynamic>;
        }
      }

      return usersData;
    } catch (e) {
      print('Error fetching users data: $e');
      return {};
    }
  }
}

================
File: app/lib/guidelines_screen.dart
================
import 'package:flutter/material.dart';

class GuidelinesScreen extends StatelessWidget {
  const GuidelinesScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Settings'),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Community Guidelines',
              style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            _buildGuideline('No PII (Personally Identifiable Information).'),
            _buildGuideline('Don\'t troll or be disrespectful to others.'),
            _buildGuideline('No hate speech or discriminatory content.'),
            _buildGuideline(
                'No posting links to malicious sites or spreading malware.'),
            _buildGuideline('No obscene or explicit content.'),
            _buildGuideline('No promotion or glorification of violence.'),
            _buildGuideline(
                'No illegal activities or content that violates laws.'),
          ],
        ),
      ),
    );
  }

  Widget _buildGuideline(String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('‚Ä¢ ',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          Expanded(child: Text(text, style: TextStyle(fontSize: 18))),
        ],
      ),
    );
  }
}

================
File: app/lib/home_screen.dart
================
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:provider/provider.dart';
import 'dart:math';
import 'app_state.dart';
import 'post_card.dart';
import 'post_screen.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    return Scaffold(
      appBar: AppBar(
        leading: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8.0),
          child: Row(
            children: [
              Icon(Icons.star, color: Colors.yellow[700], size: 18),
              SizedBox(width: 2),
              Expanded(
                child: Text(
                  '${appState.userPoints}',
                  style: TextStyle(
                    color: Colors.blue[800],
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ),
        leadingWidth: 70,
        title: PopupMenuButton<String>(
          initialValue: appState.currentFeed,
          onSelected: (String newValue) {
            appState.setCurrentFeed(newValue);
          },
          itemBuilder: (BuildContext context) =>
              appState.getAvailableFeeds().map((String feed) {
            return PopupMenuItem<String>(
              value: feed,
              child: Text(feed),
            );
          }).toList(),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.arrow_drop_down, color: Colors.blue[800]),
              Flexible(
                child: Text(
                  appState.currentFeed,
                  style: TextStyle(
                    color: Colors.blue[800],
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ),
        actions: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: ElevatedButton(
              child: Icon(Icons.add, color: Colors.white, size: 20),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue[800],
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                padding: EdgeInsets.all(8),
                minimumSize: Size(36, 36),
              ),
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) =>
                        PostScreen(currentFeed: appState.currentFeed),
                  ),
                );
              },
            ),
          ),
        ],
      ),
      body: SafeArea(
        child: DefaultTabController(
          length: 2,
          child: Column(
            children: [
              TabBar(
                tabs: [
                  Tab(text: 'Top'),
                  Tab(text: 'Recent'),
                ],
                indicatorColor: Colors.blue[800],
                labelColor: Colors.blue[800],
                unselectedLabelColor: Colors.grey,
              ),
              Expanded(
                child: TabBarView(
                  children: [
                    PostFeed(feedType: appState.currentFeed, sortBy: 'top'),
                    PostFeed(feedType: appState.currentFeed, sortBy: 'recent'),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class PostFeed extends StatelessWidget {
  final String feedType;
  final String sortBy;

  const PostFeed({Key? key, required this.feedType, required this.sortBy})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    return StreamBuilder<QuerySnapshot>(
      stream: appState.getPostsStream(feedType),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          print('Error in PostFeed: ${snapshot.error}');
          return Center(child: Text('Error: ${snapshot.error}'));
        }

        if (snapshot.connectionState == ConnectionState.waiting) {
          return Center(child: CircularProgressIndicator());
        }

        final posts = snapshot.data!.docs;
        if (sortBy == 'top') {
          posts
              .sort((a, b) => _calculateScore(b).compareTo(_calculateScore(a)));
        }

        return RefreshIndicator(
          onRefresh: () async {
            // Trigger a refresh of the stream
            await Future.delayed(Duration(seconds: 1)); // Simulated delay
            // The StreamBuilder will automatically update when the stream emits a new value
          },
          child: ListView(
            physics: AlwaysScrollableScrollPhysics(),
            children: posts.map((DocumentSnapshot document) {
              Map<String, dynamic> data =
                  document.data() as Map<String, dynamic>;
              return FutureBuilder<DocumentSnapshot>(
                future: FirebaseFirestore.instance
                    .collection('users')
                    .doc(data['userId'])
                    .get(),
                builder: (context, userSnapshot) {
                  String userName = '@anonymous';
                  String profileEmoji = 'ü´•';
                  if (userSnapshot.connectionState == ConnectionState.done) {
                    if (userSnapshot.hasData && userSnapshot.data!.exists) {
                      final userData =
                          userSnapshot.data!.data() as Map<String, dynamic>?;
                      userName = userData?['userName'] as String? ?? '';
                      profileEmoji =
                          userData?['profileEmoji'] as String? ?? 'ü´•';
                      if (userName.isEmpty) {
                        userName = '@anonymous';
                      } else {
                        userName = '@$userName';
                      }
                    } else {
                      userName = '@[deleted]';
                    }
                  }
                  return PostCard(
                    title: data['title'] ?? '',
                    content: data['content'] ?? '',
                    commentCount: data['commentCount'] ?? 0,
                    timestamp: data['timestamp']?.toDate() ?? DateTime.now(),
                    postId: document.id,
                    userId: data['userId'] ?? '',
                    profileEmoji: profileEmoji,
                    userName: userName,
                    imageUrl: data['imageUrl'],
                  );
                },
              );
            }).toList(),
          ),
        );
      },
    );
  }

  double _calculateScore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    final points = data['points'] as int? ?? 0;
    final commentCount = data['commentCount'] as int? ?? 0;
    final timestamp = data['timestamp'] as Timestamp?;

    if (timestamp == null) return 0;

    final ageInHours = DateTime.now().difference(timestamp.toDate()).inHours;
    final gravity = 1.8;

    return (points + (commentCount * 0.5)) / pow((ageInHours + 2), gravity);
  }
}

================
File: app/lib/login_screen.dart
================
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:provider/provider.dart';
import 'package:flutter_webview_plugin/flutter_webview_plugin.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'dart:async';
import 'dart:math';
import 'package:crypto/crypto.dart';
import 'app_state.dart';
import 'zone_selection_screen.dart';
import 'package:cloud_functions/cloud_functions.dart';
import 'package:flutter_web_auth/flutter_web_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({Key? key}) : super(key: key);

  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  bool _isLoading = false;
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();

  Future<UserCredential?> signInWithIdMe() async {
    print("Starting ID.me sign-in process");
    const String clientId = '0d399b555eb4574e6b761b7d2c103662';
    const String redirectUri = 'com.park.scuttle://callback';
    final String codeVerifier = _generateRandomString(128);
    final List<int> bytes = utf8.encode(codeVerifier);
    final Digest digest = sha256.convert(bytes);
    final String codeChallenge =
        base64Url.encode(digest.bytes).replaceAll('=', '');

    const String authorizationEndpoint = 'https://api.id.me/oauth/authorize';
    const String tokenEndpoint = 'https://api.id.me/oauth/token';

    // And keep the authorization URL simple
    final String authorizationUrl = '$authorizationEndpoint'
        '?client_id=$clientId'
        '&redirect_uri=${Uri.encodeComponent(redirectUri)}'
        '&response_type=code'
        '&scope=military'
        '&code_challenge=$codeChallenge'
        '&code_challenge_method=S256'
        '&show_verify=true';

    try {
      print("Initiating ID.me authentication");
      print("Authorization URL: $authorizationUrl");

      final result = await FlutterWebAuth.authenticate(
        url: authorizationUrl,
        callbackUrlScheme: "com.park.scuttle",
        preferEphemeral: true,
      ).timeout(
        Duration(minutes: 5),
        onTimeout: () {
          throw TimeoutException('Authentication timed out');
        },
      );

      print("Received result from FlutterWebAuth: $result");

      final uri = Uri.parse(result);
      final code = uri.queryParameters['code'];
      final error = uri.queryParameters['error'];
      final errorDescription = uri.queryParameters['error_description'];

      if (error != null) {
        print("Error returned from ID.me: $error");
        print("Error description: $errorDescription");
        throw Exception('Error during ID.me authorization: $errorDescription');
      }

      if (code == null) {
        print("No code found in the redirect URI");
        print("Redirect URI parameters: ${uri.queryParameters}");
        throw Exception('No code returned from ID.me');
      }

      print("Authorization code received: $code");

      print("Exchanging authorization code for access token");
      final tokenResponse = await http.post(
        Uri.parse(tokenEndpoint),
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: {
          'code': code,
          'client_id': clientId,
          'client_secret': 'ca870bd28dbb2d711cc7cef8dc267127',
          'redirect_uri': redirectUri,
          'grant_type': 'authorization_code',
          'code_verifier': codeVerifier,
        },
      ).timeout(
        Duration(seconds: 30),
        onTimeout: () {
          throw TimeoutException('Token exchange timed out');
        },
      );

      print("Token response status code: ${tokenResponse.statusCode}");
      print("Token response body: ${tokenResponse.body}");

      if (tokenResponse.statusCode == 200) {
        print("Access token obtained successfully");
        final tokenData = json.decode(tokenResponse.body);
        final accessToken = tokenData['access_token'];

        print("Calling Firebase Function");
        final callable =
            FirebaseFunctions.instance.httpsCallable('createFirebaseToken');
        final result = await callable.call({'idmeToken': accessToken}).timeout(
          Duration(seconds: 30),
          onTimeout: () {
            throw TimeoutException('Firebase function timed out');
          },
        );

        print("Firebase Function result: ${result.data}");

        final customToken = result.data['customToken'];
        if (customToken == null) {
          throw Exception('No custom token returned from Firebase');
        }

        print("Firebase custom token obtained");
        final userCredential =
            await FirebaseAuth.instance.signInWithCustomToken(customToken);

        print("Signed in to Firebase successfully");
        if (!mounted) return null;

        await Provider.of<AppState>(context, listen: false)
            .setIdMeVerified(true);

        return userCredential;
      } else {
        print(
            "Failed to obtain access token. Status code: ${tokenResponse.statusCode}");
        print("Response body: ${tokenResponse.body}");
        throw Exception('Failed to obtain access token: ${tokenResponse.body}');
      }
    } catch (e) {
      print("Error during ID.me sign-in: $e");
      if (e is TimeoutException) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
                content: Text('The operation timed out. Please try again.')),
          );
        }
      } else if (e is FirebaseFunctionsException) {
        print("Firebase Functions Exception: ${e.code} - ${e.message}");
        print("Firebase Functions Exception details: ${e.details}");
        if (mounted) {
          String message;
          if (e.code == 'permission-denied') {
            if (e.message!.contains('not verified by ID.me')) {
              message =
                  'Your ID.me account is not verified. Please verify your account with ID.me and try again.';
            } else if (e.message!.contains('does not have military status')) {
              message =
                  'You must have a verified military status with ID.me to use this app.';
            } else {
              message =
                  'You do not have permission to use this app. Please ensure you have a verified military status with ID.me.';
            }
          } else {
            message = 'An error occurred during sign-in: ${e.message}';
          }
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(message)),
          );
        }
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('An error occurred: ${e.toString()}')),
          );
        }
      }
      return null;
    }
  }

  Future<UserCredential?> signInWithEmailPassword() async {
    try {
      final UserCredential userCredential =
          await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text,
      );
      return userCredential;
    } catch (e) {
      print('Error during email/password sign in: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Login failed: ${e.toString()}')),
        );
      }
      return null;
    }
  }

  String _generateRandomString(int length) {
    const chars =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
    final random = Random.secure();
    return List.generate(length, (index) => chars[random.nextInt(chars.length)])
        .join();
  }

  void _handleSignIn(Future<UserCredential?> Function() signInMethod) async {
    if (_isLoading) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final UserCredential? userCredential = await signInMethod();
      if (userCredential != null && userCredential.user != null && mounted) {
        final user = userCredential.user!;
        final appState = Provider.of<AppState>(context, listen: false);

        bool userExists = await appState.checkUserExists(user.uid);

        if (!userExists) {
          await appState.createUserDocument(user.uid);
        }

        await appState.initializeUser(user.uid);

        Navigator.of(context).pushReplacement(
          MaterialPageRoute(
            builder: (context) => ZoneSelectionScreen(isInitialSetup: true),
          ),
        );
      } else {
        throw Exception('Failed to sign in');
      }
    } catch (e) {
      print('Error during sign in: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to sign in: ${e.toString()}')),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Image.asset(
                    'assets/AppIcon-1024-Transparent.png',
                    height: 64,
                    width: 64,
                  ),
                  Text(
                    'Scuttle',
                    style: TextStyle(
                      fontSize: 48,
                      fontWeight: FontWeight.bold,
                      color: Colors.blue[800],
                    ),
                  ),
                ],
              ),
              SizedBox(height: 50),
              _buildSignInButton(
                onPressed:
                    _isLoading ? null : () => _handleSignIn(signInWithIdMe),
                icon: Image.asset(
                  'assets/idme_logo.png',
                  height: 24.0,
                  errorBuilder: (context, error, stackTrace) {
                    return Icon(Icons.verified_user,
                        size: 24, color: Colors.blue);
                  },
                ),
                text: 'Sign in with ID.me',
              ),
              SizedBox(height: 16),
              _buildSignInButton(
                onPressed: _isLoading ? null : () => _showEmailPasswordDialog(),
                icon: Icon(Icons.login, size: 24, color: Colors.green),
                text: 'App Store Review Access',
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showEmailPasswordDialog() {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('App Store Reviewer Login'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: _emailController,
                decoration: InputDecoration(labelText: 'Email'),
                keyboardType: TextInputType.emailAddress,
              ),
              TextField(
                controller: _passwordController,
                decoration: InputDecoration(labelText: 'Password'),
                obscureText: true,
              ),
            ],
          ),
          actions: [
            TextButton(
              child: Text('Cancel'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: Text('Login'),
              onPressed: () {
                Navigator.of(context).pop();
                _handleSignIn(signInWithEmailPassword);
              },
            ),
          ],
        );
      },
    );
  }

  Widget _buildSignInButton({
    required VoidCallback? onPressed,
    required Widget icon,
    required String text,
  }) {
    return SizedBox(
      width: double.infinity,
      child: ElevatedButton(
        style: ElevatedButton.styleFrom(
          foregroundColor: Colors.black,
          backgroundColor: Colors.white,
          padding: EdgeInsets.symmetric(horizontal: 20, vertical: 15),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
        onPressed: onPressed,
        child: _isLoading
            ? CircularProgressIndicator()
            : Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  icon,
                  SizedBox(width: 10),
                  Flexible(
                    child: Text(
                      text,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
      ),
    );
  }
}

================
File: app/lib/main.dart
================
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:cloud_functions/cloud_functions.dart';
import 'app_state.dart';
import 'scuttlebutt_app.dart';
import 'login_screen.dart';
import 'zone_selection_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();

  if (const bool.fromEnvironment('USE_FIREBASE_EMU')) {
    FirebaseFunctions.instance.useFunctionsEmulator('localhost', 5001);
  }

  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => AppState(),
      child: MaterialApp(
        title: 'Scuttle',
        theme: ThemeData(
          primarySwatch: Colors.blue,
          visualDensity: VisualDensity.adaptivePlatformDensity,
        ),
        home: AuthWrapper(),
      ),
    );
  }
}

class AuthWrapper extends StatelessWidget {
  Future<bool> _checkFirstInstall() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    bool isFirstInstall = prefs.getBool('is_first_install') ?? true;
    if (isFirstInstall) {
      await prefs.setBool('is_first_install', false);
    }
    return isFirstInstall;
  }

  Future<bool> _checkZoneAcknowledged() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    return prefs.getBool('zone_acknowledged') ?? false;
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<bool>(
      future: _checkFirstInstall(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.done) {
          bool isFirstInstall = snapshot.data ?? true;

          if (isFirstInstall) {
            return LoginScreen();
          } else {
            return StreamBuilder<User?>(
              stream: FirebaseAuth.instance.authStateChanges(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.active) {
                  User? user = snapshot.data;
                  if (user == null) {
                    return LoginScreen();
                  }
                  return FutureBuilder<void>(
                    future: _initializeUserData(context, user),
                    builder: (context, snapshot) {
                      if (snapshot.connectionState == ConnectionState.done) {
                        return FutureBuilder<bool>(
                          future: _checkZoneAcknowledged(),
                          builder: (context, snapshot) {
                            if (snapshot.connectionState ==
                                ConnectionState.done) {
                              bool zoneAcknowledged = snapshot.data ?? false;
                              final appState =
                                  Provider.of<AppState>(context, listen: false);
                              if (!zoneAcknowledged || appState.isNewUser) {
                                return ZoneSelectionScreen(
                                    isInitialSetup: true);
                              }
                              return ScuttleHomePage();
                            }
                            return Scaffold(
                                body:
                                    Center(child: CircularProgressIndicator()));
                          },
                        );
                      }
                      return Scaffold(
                          body: Center(child: CircularProgressIndicator()));
                    },
                  );
                }
                return Scaffold(
                    body: Center(child: CircularProgressIndicator()));
              },
            );
          }
        }
        return Scaffold(body: Center(child: CircularProgressIndicator()));
      },
    );
  }

  Future<void> _initializeUserData(BuildContext context, User user) async {
    final appState = Provider.of<AppState>(context, listen: false);
    await appState.initializeUser(user.uid);

    // Check if the user has points, if not, calculate them
    if (appState.userPoints == 0) {
      await appState.calculateAndSetInitialPoints();
    }
  }
}

================
File: app/lib/post_card.dart
================
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:provider/provider.dart';
import 'app_state.dart';
import 'post_detail_screen.dart';

class PostCard extends StatelessWidget {
  final String title;
  final String content;
  final int commentCount;
  final DateTime timestamp;
  final String postId;
  final String userId;
  final String profileEmoji;
  final String userName;
  final bool isDetailView;
  final String? imageUrl;

  const PostCard({
    Key? key,
    required this.title,
    required this.content,
    required this.commentCount,
    required this.timestamp,
    required this.postId,
    required this.userId,
    required this.profileEmoji,
    required this.userName,
    this.isDetailView = false,
    this.imageUrl,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final isCreator = appState.userId == userId;
    final isSaved = appState.savedPosts.contains(postId);

    return Card(
      margin: EdgeInsets.all(8.0),
      child: InkWell(
        onTap: isDetailView
            ? null
            : () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => PostDetailScreen(postId: postId),
                  ),
                );
              },
        child: Padding(
          padding: EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Expanded(
                    child: Row(
                      children: [
                        Text(profileEmoji),
                        SizedBox(width: 4),
                        Text(
                          userName,
                          style: TextStyle(
                            fontSize: 14,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        SizedBox(width: 8),
                        Text(
                          getRelativeTime(timestamp),
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey[600],
                          ),
                        ),
                      ],
                    ),
                  ),
                  if (isCreator && !isDetailView)
                    IconButton(
                      icon: Icon(Icons.delete, size: 20),
                      onPressed: () =>
                          _showDeleteConfirmation(context, appState),
                      padding: EdgeInsets.zero,
                      constraints: BoxConstraints(),
                      alignment: Alignment.centerRight,
                    ),
                ],
              ),
              SizedBox(height: 8),
              Text(
                title,
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              SizedBox(height: 4),
              Text(
                content,
                maxLines: isDetailView ? null : 3,
                overflow:
                    isDetailView ? TextOverflow.visible : TextOverflow.ellipsis,
              ),
              if (imageUrl != null) ...[
                SizedBox(height: 8),
                ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: Image.network(
                    imageUrl!,
                    fit: BoxFit.contain,
                    width: double.infinity,
                    height: isDetailView
                        ? null
                        : 200, // Set a fixed height for feed view
                  ),
                ),
              ],
              SizedBox(height: 8),
              StreamBuilder<DocumentSnapshot>(
                stream: appState.getPostStream(postId),
                builder: (context, snapshot) {
                  if (!snapshot.hasData) {
                    return CircularProgressIndicator();
                  }
                  final postData =
                      snapshot.data!.data() as Map<String, dynamic>;
                  final points = postData['points'] as int? ?? 0;
                  final userVote = appState.userVotes[postId] ?? 0;

                  return Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Row(
                        children: [
                          IconButton(
                            icon: Icon(
                              Icons.arrow_upward,
                              color: userVote == 1 ? Colors.orange : null,
                            ),
                            onPressed: () {
                              appState.updatePostPoints(postId, 1);
                            },
                          ),
                          Text('$points'),
                          IconButton(
                            icon: Icon(
                              Icons.arrow_downward,
                              color: userVote == -1 ? Colors.blue : null,
                            ),
                            onPressed: () {
                              appState.updatePostPoints(postId, -1);
                            },
                          ),
                          SizedBox(width: 16),
                          Icon(Icons.comment),
                          SizedBox(width: 4),
                          Text('$commentCount'),
                        ],
                      ),
                      IconButton(
                        icon: Icon(
                          isSaved ? Icons.bookmark : Icons.bookmark_border,
                          color: isSaved ? Colors.grey[700] : null,
                        ),
                        onPressed: () {
                          appState.toggleSavedPost(postId);
                        },
                      ),
                    ],
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  void _showDeleteConfirmation(BuildContext context, AppState appState) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Delete Post'),
          content: Text(
              'Are you sure you want to delete this post? This action cannot be undone.'),
          actions: <Widget>[
            TextButton(
              child: Text('Cancel'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: Text('Delete', style: TextStyle(color: Colors.red)),
              onPressed: () {
                appState.deletePost(postId);
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }
}

String getRelativeTime(DateTime dateTime) {
  final now = DateTime.now();
  final difference = now.difference(dateTime);

  if (difference.inSeconds < 60) {
    return 'Now';
  } else if (difference.inMinutes < 60) {
    return '${difference.inMinutes} min';
  } else if (difference.inHours < 24) {
    return '${difference.inHours} hr';
  } else if (difference.inDays < 30) {
    return '${difference.inDays} day${difference.inDays == 1 ? '' : 's'}';
  } else if (difference.inDays < 365) {
    final months = (difference.inDays / 30).floor();
    return '$months month${months == 1 ? '' : 's'}';
  } else {
    final years = (difference.inDays / 365).floor();
    return '$years year${years == 1 ? '' : 's'}';
  }
}

================
File: app/lib/post_detail_screen.dart
================
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:provider/provider.dart';
import 'app_state.dart';
import 'post_card.dart';

class PostDetailScreen extends StatelessWidget {
  final String postId;

  const PostDetailScreen({Key? key, required this.postId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Post Details'),
      ),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: StreamBuilder<DocumentSnapshot>(
                stream: FirebaseFirestore.instance
                    .collection('posts')
                    .doc(postId)
                    .snapshots(),
                builder: (context, snapshot) {
                  if (snapshot.hasError) {
                    print('Error in PostDetailScreen: ${snapshot.error}');
                    return Center(child: Text('Error: ${snapshot.error}'));
                  }

                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return Center(child: CircularProgressIndicator());
                  }

                  Map<String, dynamic> postData =
                      snapshot.data!.data() as Map<String, dynamic>;

                  return FutureBuilder<DocumentSnapshot>(
                    future: FirebaseFirestore.instance
                        .collection('users')
                        .doc(postData['userId'])
                        .get(),
                    builder: (context, userSnapshot) {
                      String userName = '@anonymous';
                      String profileEmoji = 'ü´•';
                      if (userSnapshot.connectionState ==
                          ConnectionState.done) {
                        if (userSnapshot.hasData && userSnapshot.data!.exists) {
                          final userData = userSnapshot.data!.data()
                              as Map<String, dynamic>?;
                          userName = userData?['userName'] as String? ?? '';
                          profileEmoji =
                              userData?['profileEmoji'] as String? ?? 'ü´•';
                          if (userName.isEmpty) {
                            userName = '@anonymous';
                          } else {
                            userName = '@$userName';
                          }
                        } else {
                          userName = '@[deleted]';
                        }
                      }

                      return ListView(
                        padding: EdgeInsets.all(16.0),
                        children: [
                          Text(
                            'Feed: ${postData['feed'] ?? 'Unknown'}',
                            style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.blue[800],
                            ),
                          ),
                          SizedBox(height: 8),
                          PostCard(
                            title: postData['title'] ?? '',
                            content: postData['content'] ?? '',
                            commentCount: postData['commentCount'] ?? 0,
                            timestamp: postData['timestamp']?.toDate() ??
                                DateTime.now(),
                            postId: postId,
                            userId: postData['userId'] ?? '',
                            profileEmoji: profileEmoji,
                            userName: userName,
                            isDetailView: true,
                            imageUrl: postData['imageUrl'],
                          ),
                          Divider(),
                          Text(
                            'Comments',
                            style: TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          SizedBox(height: 8),
                          CommentList(postId: postId),
                        ],
                      );
                    },
                  );
                },
              ),
            ),
            CommentInput(postId: postId),
          ],
        ),
      ),
    );
  }
}

class FullScreenImage extends StatelessWidget {
  final String imageUrl;

  const FullScreenImage({Key? key, required this.imageUrl}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GestureDetector(
        onTap: () => Navigator.of(context).pop(),
        child: Center(
          child: Hero(
            tag: imageUrl,
            child: Image.network(
              imageUrl,
              fit: BoxFit.contain,
              width: double.infinity,
              height: double.infinity,
            ),
          ),
        ),
      ),
    );
  }
}

class CommentList extends StatelessWidget {
  final String postId;

  const CommentList({Key? key, required this.postId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('comments')
          .where('postId', isEqualTo: postId)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          print('Error in CommentList: ${snapshot.error}');
          return Center(child: Text('Error loading comments'));
        }

        if (snapshot.connectionState == ConnectionState.waiting) {
          return Center(child: CircularProgressIndicator());
        }

        final commentDocs = snapshot.data!.docs;

        // Sort comments by points (votes) in descending order
        commentDocs.sort((a, b) {
          final aPoints =
              (a.data() as Map<String, dynamic>)['points'] as int? ?? 0;
          final bPoints =
              (b.data() as Map<String, dynamic>)['points'] as int? ?? 0;
          return bPoints.compareTo(aPoints);
        });

        return ListView.builder(
          shrinkWrap: true,
          physics: NeverScrollableScrollPhysics(),
          itemCount: commentDocs.length,
          itemBuilder: (context, index) {
            final commentDoc = commentDocs[index];
            final commentData = commentDoc.data() as Map<String, dynamic>;

            return FutureBuilder<DocumentSnapshot>(
              future: FirebaseFirestore.instance
                  .collection('users')
                  .doc(commentData['userId'])
                  .get(),
              builder: (context, userSnapshot) {
                if (userSnapshot.connectionState == ConnectionState.waiting) {
                  return CircularProgressIndicator();
                }

                String userName = '@anonymous';
                String profileEmoji = 'ü´•';

                if (userSnapshot.connectionState == ConnectionState.done) {
                  if (userSnapshot.hasData && userSnapshot.data!.exists) {
                    final userData =
                        userSnapshot.data!.data() as Map<String, dynamic>?;
                    userName = userData?['userName'] as String? ?? '';
                    profileEmoji = userData?['profileEmoji'] as String? ?? 'ü´•';
                    if (userName.isEmpty) {
                      userName = '@anonymous';
                    } else {
                      userName = '@$userName';
                    }
                  } else {
                    userName = '@[deleted]';
                  }
                }

                return CommentCard(
                  content: commentData['content'] ?? '',
                  timestamp:
                      commentData['timestamp']?.toDate() ?? DateTime.now(),
                  commentId: commentDoc.id,
                  userId: commentData['userId'] ?? '',
                  postId: postId,
                  userName: userName,
                  profileEmoji: profileEmoji,
                );
              },
            );
          },
        );
      },
    );
  }
}

class CommentCard extends StatelessWidget {
  final String content;
  final DateTime timestamp;
  final String commentId;
  final String userId;
  final String postId;
  final String userName;
  final String profileEmoji;

  const CommentCard({
    Key? key,
    required this.content,
    required this.timestamp,
    required this.commentId,
    required this.userId,
    required this.postId,
    required this.userName,
    required this.profileEmoji,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);

    return Card(
      margin: EdgeInsets.symmetric(vertical: 4.0),
      child: Padding(
        padding: EdgeInsets.all(8.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    Text(profileEmoji),
                    SizedBox(width: 4),
                    Text(
                      userName,
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                if (userId == appState.userId)
                  IconButton(
                    icon: Icon(Icons.delete, size: 20),
                    onPressed: () =>
                        _showDeleteCommentConfirmation(context, appState),
                    padding: EdgeInsets.zero,
                    constraints: BoxConstraints(),
                  ),
              ],
            ),
            SizedBox(height: 4),
            Text(content),
            SizedBox(height: 4),
            StreamBuilder<DocumentSnapshot>(
              stream: appState.getCommentStream(commentId),
              builder: (context, snapshot) {
                if (!snapshot.hasData) {
                  return CircularProgressIndicator();
                }
                final commentData =
                    snapshot.data!.data() as Map<String, dynamic>;
                final points = commentData['points'] as int? ?? 0;
                final currentVote = appState.userCommentVotes[commentId] ?? 0;

                return Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Row(
                      children: [
                        IconButton(
                          icon: Icon(
                            Icons.arrow_upward,
                            size: 16,
                            color: currentVote == 1 ? Colors.orange : null,
                          ),
                          onPressed: () {
                            appState.updateCommentPoints(commentId, 1);
                          },
                        ),
                        Text('$points', style: TextStyle(fontSize: 12)),
                        IconButton(
                          icon: Icon(
                            Icons.arrow_downward,
                            size: 16,
                            color: currentVote == -1 ? Colors.blue : null,
                          ),
                          onPressed: () {
                            appState.updateCommentPoints(commentId, -1);
                          },
                        ),
                      ],
                    ),
                    Text(
                      getRelativeTime(timestamp),
                      style: TextStyle(
                        color: Colors.grey[600],
                        fontSize: 12,
                      ),
                    ),
                  ],
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  void _showDeleteCommentConfirmation(BuildContext context, AppState appState) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Delete Comment'),
          content: Text(
              'Are you sure you want to delete this comment? This action cannot be undone.'),
          actions: <Widget>[
            TextButton(
              child: Text('Cancel'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: Text('Delete', style: TextStyle(color: Colors.red)),
              onPressed: () {
                appState.deleteComment(postId, commentId);
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }
}

class CommentInput extends StatefulWidget {
  final String postId;

  const CommentInput({Key? key, required this.postId}) : super(key: key);

  @override
  _CommentInputState createState() => _CommentInputState();
}

class _CommentInputState extends State<CommentInput> {
  final TextEditingController _commentController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.fromLTRB(8.0, 8.0, 8.0, 20.0),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _commentController,
              decoration: InputDecoration(
                hintText: 'Add a comment...',
                border: OutlineInputBorder(),
              ),
            ),
          ),
          SizedBox(width: 8.0),
          ElevatedButton(
            onPressed: () {
              if (_commentController.text.isNotEmpty) {
                Provider.of<AppState>(context, listen: false).createComment(
                  widget.postId,
                  _commentController.text,
                );
                _commentController.clear();
              }
            },
            child: Text('Post'),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _commentController.dispose();
    super.dispose();
  }
}

String getRelativeTime(DateTime dateTime) {
  final now = DateTime.now();
  final difference = now.difference(dateTime);

  if (difference.inSeconds < 60) {
    return 'Now';
  } else if (difference.inMinutes < 60) {
    return '${difference.inMinutes} min';
  } else if (difference.inHours < 24) {
    return '${difference.inHours} hr';
  } else {
    return '${difference.inDays} day${difference.inDays == 1 ? '' : 's'}';
  }
}

================
File: app/lib/post_screen.dart
================
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io';
import 'app_state.dart';

class PostScreen extends StatefulWidget {
  final String currentFeed;

  const PostScreen({Key? key, required this.currentFeed}) : super(key: key);

  @override
  _PostScreenState createState() => _PostScreenState();
}

class _PostScreenState extends State<PostScreen> {
  final TextEditingController _titleController = TextEditingController();
  final TextEditingController _bodyController = TextEditingController();
  File? _image;

  Future<void> _getImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: ImageSource.gallery);

    setState(() {
      if (pickedFile != null) {
        _image = File(pickedFile.path);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final feedName = widget.currentFeed == 'All Navy'
        ? 'All Navy'
        : appState.command ?? 'Local Feed';

    return Scaffold(
      appBar: AppBar(
        title: Text('Create Post in $feedName'),
      ),
      body: SafeArea(
        child: ListView(
          padding: const EdgeInsets.all(16.0),
          children: [
            Card(
              color: Colors.blue[50],
              child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: Row(
                  children: [
                    Icon(Icons.info_outline, color: Colors.blue[800]),
                    SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'Your post will appear in the $feedName feed',
                        style: TextStyle(color: Colors.blue[800]),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            SizedBox(height: 16),
            TextField(
              controller: _titleController,
              decoration: InputDecoration(
                hintText: 'Title',
                border: OutlineInputBorder(),
              ),
              maxLines: 1,
            ),
            SizedBox(height: 16),
            TextField(
              controller: _bodyController,
              decoration: InputDecoration(
                hintText: 'What\'s on your mind?',
                border: OutlineInputBorder(),
              ),
              maxLines: 5,
            ),
            SizedBox(height: 16),
            ElevatedButton.icon(
              onPressed: _getImage,
              icon: Icon(Icons.add_photo_alternate),
              label: Text('Add Image'),
            ),
            if (_image != null) ...[
              SizedBox(height: 16),
              ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.file(_image!, height: 200, fit: BoxFit.cover),
              ),
            ],
            SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: () {
                      Navigator.pop(context);
                    },
                    child: Text('Cancel'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.grey,
                    ),
                  ),
                ),
                SizedBox(width: 16),
                Expanded(
                  child: ElevatedButton(
                    onPressed: () async {
                      if (_titleController.text.isNotEmpty &&
                          _bodyController.text.isNotEmpty) {
                        await appState.createPost(
                          _titleController.text,
                          _bodyController.text,
                          widget.currentFeed,
                          image: _image,
                        );
                        Navigator.pop(context);
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                              content: Text(
                                  'Post created successfully in $feedName')),
                        );
                      } else {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                              content:
                                  Text('Please enter both title and content')),
                        );
                      }
                    },
                    child: Text('Post'),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    _titleController.dispose();
    _bodyController.dispose();
    super.dispose();
  }
}

================
File: app/lib/privacy_policy_screen.dart
================
import 'package:flutter/material.dart';

class PrivacyPolicyScreen extends StatelessWidget {
  const PrivacyPolicyScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Settings'),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'PRIVACY POLICY',
              style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            _buildParagraph(
              'Welcome to Scuttle. We respect your privacy and are committed to protecting your personal data. This privacy policy explains how we collect, use, and safeguard your information when you use our app.',
            ),
            SizedBox(height: 16),
            _buildSection('INFORMATION WE COLLECT',
                'We may collect the following types of information: location data, user-generated content, usage data and app activity, and information from third-party services.'),
            _buildSection('HOW WE USE YOUR INFORMATION',
                'We use your information to provide and improve our services, personalize your experience, facilitate social features and sharing, communicate with you about the app and your account, and ensure the security and functionality of our app.'),
            _buildSection('DATA SHARING AND DISCLOSURE',
                'We may share your information with other users, based on your privacy settings, and with third-party service providers who assist in our operations.'),
            _buildSection('YOUR CHOICES AND RIGHTS',
                'You can access, update, or delete your personal information, adjust your privacy settings within the app, and opt-out of certain data collection or use.'),
            _buildSection('DATA SECURITY',
                'We implement appropriate technical and organizational measures to protect your data.'),
            _buildSection('CHANGES TO THIS POLICY',
                'We may update this policy from time to time. We will notify you of any significant changes.'),
            _buildSection('CONTACT US',
                'If you have any questions about this privacy policy, please contact us at jpslvtr@gmail.com.\n'),
          ],
        ),
      ),
    );
  }

  Widget _buildSection(String title, String content) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
        ),
        SizedBox(height: 8),
        _buildParagraph(content),
        SizedBox(height: 16),
      ],
    );
  }

  Widget _buildParagraph(String text) {
    return Text(
      text,
      style: TextStyle(fontSize: 18),
    );
  }
}

================
File: app/lib/profile_screen.dart
================
// File: app/lib/profile_screen.dart

import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:provider/provider.dart';
import 'app_state.dart';
import 'login_screen.dart';
import 'post_detail_screen.dart';
import 'post_card.dart';

class ProfileScreen extends StatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  _ProfileScreenState createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    return SafeArea(
      child: Column(
        children: [
          _buildProfileHeader(appState),
          TabBar(
            controller: _tabController,
            tabs: [
              Tab(text: 'My Posts'),
              Tab(text: 'My Comments'),
              Tab(text: 'Saved'),
            ],
            indicatorColor: Colors.blue[800],
            labelColor: Colors.blue[800],
            unselectedLabelColor: Colors.grey,
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildPostsList(appState),
                _buildCommentsList(appState),
                _buildSavedPostsList(appState),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildProfileHeader(AppState appState) {
    return FutureBuilder<Map<String, dynamic>>(
      future: appState.getUserProfile(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return CircularProgressIndicator();
        }
        if (snapshot.hasError) {
          print('Error in _buildProfileHeader: ${snapshot.error}');
          return Text('Error loading profile: ${snapshot.error}');
        }
        final userData = snapshot.data ?? {};
        final displayName = userData['userName']?.isEmpty ?? true
            ? '@anonymous'
            : '@${userData['userName']}';
        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                userData['profileEmoji'] ?? 'üôÇ',
                style: TextStyle(fontSize: 40),
              ),
              SizedBox(width: 16),
              Text(
                displayName,
                style: TextStyle(fontSize: 20),
              ),
              SizedBox(width: 8),
              IconButton(
                icon: Icon(
                  Icons.edit,
                  size: 20.0,
                ),
                onPressed: () => _showEditOptions(context, appState, userData),
              ),
            ],
          ),
        );
      },
    );
  }

  void _showEditOptions(
      BuildContext context, AppState appState, Map<String, dynamic> userData) {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              ListTile(
                leading: Icon(Icons.emoji_emotions),
                title: Text('Change emoji'),
                onTap: () {
                  Navigator.pop(context);
                  _showEmojiPicker(context, appState);
                },
              ),
              ListTile(
                leading: Icon(Icons.edit),
                title: Text('Set/edit username'),
                onTap: () {
                  Navigator.pop(context);
                  _showUsernameEditor(context, appState, userData['userName']);
                },
              ),
            ],
          ),
        );
      },
    );
  }

  void _showEmojiPicker(BuildContext context, AppState appState) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Choose an emoji'),
          content: Wrap(
            spacing: 10,
            children: [
              'üôÇ', 'üôÉ', 'üòê', 'üò¨', 'ü•≤', 'ü§î', 'ü§∑', 'ü§∑‚Äç‚ôÄÔ∏è', 'ü´°', 'üò≥',
              'ü´£', 'üôÑ', 'üßê', 'üò¥', 'üòé', 'ü´®', 'üíÄ', 'ü§°', 'ü•∏', 'üëæ'
            ]
                .map((emoji) => GestureDetector(
                      onTap: () {
                        appState.updateProfileEmoji(emoji);
                        Navigator.of(context).pop();
                      },
                      child: Text(emoji, style: TextStyle(fontSize: 40)),
                    ))
                .toList(),
          ),
        );
      },
    );
  }

  void _showUsernameEditor(
      BuildContext context, AppState appState, String? currentUsername) {
    final TextEditingController controller =
        TextEditingController(text: currentUsername);
    String? errorText;

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (BuildContext context, StateSetter setState) {
            return AlertDialog(
              title: Text('Set/edit username'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextField(
                    controller: controller,
                    decoration: InputDecoration(
                      labelText: 'Username',
                      errorText: errorText,
                    ),
                    onChanged: (value) {
                      setState(() {
                        errorText = null;
                      });
                    },
                    maxLength: 15,
                  ),
                  SizedBox(height: 16),
                  Text(
                    'Letters, numbers, periods, and underscores. Leave empty for anonymous.',
                    style: TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                ],
              ),
              actions: [
                TextButton(
                  child: Text('Cancel'),
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                ),
                TextButton(
                  child: Text('Save'),
                  onPressed: () async {
                    final newUsername = controller.text.trim();
                    if (newUsername.toLowerCase() == 'anonymous') {
                      setState(() {
                        errorText = 'Username "anonymous" is not allowed';
                      });
                    } else if (newUsername.length > 15) {
                      setState(() {
                        errorText = 'Username must be 15 characters or less';
                      });
                    } else if (_isValidUserName(newUsername) ||
                        newUsername.isEmpty) {
                      final isAvailable =
                          await appState.isUserNameAvailable(newUsername);
                      if (isAvailable || newUsername == currentUsername) {
                        await appState
                            .updateUserProfile({'userName': newUsername});
                        Navigator.of(context).pop();
                      } else {
                        setState(() {
                          errorText = 'Username is not available';
                        });
                      }
                    } else {
                      setState(() {
                        errorText = 'Invalid username format';
                      });
                    }
                  },
                ),
              ],
            );
          },
        );
      },
    );
  }

  bool _isValidUserName(String userName) {
    final RegExp validCharacters = RegExp(r'^[a-zA-Z0-9._]+$');
    return validCharacters.hasMatch(userName);
  }

  Widget _buildPostsList(AppState appState) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('posts')
          .where('userId', isEqualTo: appState.userId)
          .orderBy('timestamp', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          print('Error in _buildPostsList: ${snapshot.error}');
          return Center(child: Text('Error loading posts'));
        }
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Center(child: CircularProgressIndicator());
        }
        final posts = snapshot.data!.docs;
        if (posts.isEmpty) {
          return Center(child: Text('No posts yet'));
        }
        return ListView.builder(
          itemCount: posts.length,
          itemBuilder: (context, index) {
            final post = posts[index].data() as Map<String, dynamic>;
            return FutureBuilder<DocumentSnapshot>(
              future: FirebaseFirestore.instance
                  .collection('users')
                  .doc(post['userId'])
                  .get(),
              builder: (context, userSnapshot) {
                String userName = '@anonymous';
                String profileEmoji = 'ü´•';
                if (userSnapshot.connectionState == ConnectionState.done) {
                  if (userSnapshot.hasData && userSnapshot.data!.exists) {
                    final userData =
                        userSnapshot.data!.data() as Map<String, dynamic>?;
                    userName = userData?['userName'] as String? ?? '';
                    profileEmoji = userData?['profileEmoji'] as String? ?? 'ü´•';
                    if (userName.isEmpty) {
                      userName = '@anonymous';
                    } else {
                      userName = '@$userName';
                    }
                  } else {
                    userName = '@[deleted]';
                  }
                }
                return PostCard(
                  title: post['title'] ?? '',
                  content: post['content'] ?? '',
                  commentCount: post['commentCount'] ?? 0,
                  timestamp: post['timestamp']?.toDate() ?? DateTime.now(),
                  postId: posts[index].id,
                  userId: post['userId'] ?? '',
                  profileEmoji: profileEmoji,
                  userName: userName,
                );
              },
            );
          },
        );
      },
    );
  }

  Widget _buildCommentsList(AppState appState) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('comments')
          .where('userId', isEqualTo: appState.userId)
          .orderBy('timestamp', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Center(child: CircularProgressIndicator());
        }

        if (snapshot.hasError) {
          print('Error in _buildCommentsList: ${snapshot.error}');
          return Center(child: Text('Error loading comments'));
        }

        if (!snapshot.hasData ||
            snapshot.data == null ||
            snapshot.data!.docs.isEmpty) {
          return Center(child: Text('No comments yet'));
        }

        final comments = snapshot.data!.docs;

        return ListView.builder(
          itemCount: comments.length,
          itemBuilder: (context, index) {
            final commentData = comments[index].data() as Map<String, dynamic>?;
            if (commentData == null) {
              return SizedBox.shrink();
            }

            return FutureBuilder<DocumentSnapshot>(
              future: FirebaseFirestore.instance
                  .collection('posts')
                  .doc(commentData['postId'])
                  .get(),
              builder: (context, postSnapshot) {
                if (postSnapshot.connectionState == ConnectionState.waiting) {
                  return Card(
                    margin: EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                    child: ListTile(title: Text('Loading...')),
                  );
                }

                if (postSnapshot.hasError ||
                    !postSnapshot.hasData ||
                    postSnapshot.data == null) {
                  print(
                      'Error loading post for comment: ${postSnapshot.error}');
                  return SizedBox.shrink();
                }

                final postData =
                    postSnapshot.data!.data() as Map<String, dynamic>?;
                if (postData == null) {
                  return SizedBox.shrink();
                }

                return _buildCommentCard(context, appState, commentData,
                    postData, comments[index].id);
              },
            );
          },
        );
      },
    );
  }

  Widget _buildCommentCard(
      BuildContext context,
      AppState appState,
      Map<String, dynamic> commentData,
      Map<String, dynamic> postData,
      String commentId) {
    return Card(
      margin: EdgeInsets.symmetric(vertical: 8, horizontal: 16),
      child: InkWell(
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) =>
                  PostDetailScreen(postId: commentData['postId']),
            ),
          );
        },
        child: Padding(
          padding: EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Text(
                      postData['title'] ?? '',
                      style: TextStyle(
                        fontSize: 16,
                      ),
                    ),
                  ),
                  IconButton(
                    icon: Icon(Icons.delete, size: 20),
                    onPressed: () => _showDeleteCommentConfirmation(
                        context, appState, commentData['postId'], commentId),
                    padding: EdgeInsets.zero,
                    constraints: BoxConstraints(),
                  ),
                ],
              ),
              SizedBox(height: 8),
              Row(
                children: [
                  FutureBuilder<DocumentSnapshot>(
                    future: FirebaseFirestore.instance
                        .collection('users')
                        .doc(postData['userId'])
                        .get(),
                    builder: (context, userSnapshot) {
                      if (userSnapshot.connectionState ==
                          ConnectionState.waiting) {
                        return Text('@loading...');
                      }
                      if (userSnapshot.hasError || !userSnapshot.hasData) {
                        print('Error loading user data: ${userSnapshot.error}');
                        return Text('@[deleted]');
                      }
                      final userData =
                          userSnapshot.data!.data() as Map<String, dynamic>?;
                      final userName = userData?['userName'] as String?;
                      return Text(
                        userName == null || userName.isEmpty
                            ? '@[deleted]'
                            : '@$userName',
                        style: TextStyle(
                          fontSize: 14,
                          color: Colors.grey[600],
                        ),
                      );
                    },
                  ),
                  SizedBox(width: 8),
                  Text(
                    getRelativeTime(commentData['timestamp'].toDate()),
                    style: TextStyle(
                      color: Colors.grey[600],
                      fontSize: 14,
                    ),
                  ),
                  SizedBox(width: 8),
                  Icon(Icons.arrow_upward, size: 14, color: Colors.red),
                  SizedBox(width: 4),
                  Text(
                    '${commentData['points']}',
                    style: TextStyle(fontSize: 14),
                  ),
                ],
              ),
              SizedBox(height: 8),
              Text(
                commentData['content'] ?? '',
                style: TextStyle(),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showDeleteCommentConfirmation(BuildContext context, AppState appState,
      String postId, String commentId) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Delete Comment'),
          content: Text(
              'Are you sure you want to delete this comment? This action cannot be undone.'),
          actions: <Widget>[
            TextButton(
              child: Text('Cancel'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: Text('Delete', style: TextStyle(color: Colors.red)),
              onPressed: () {
                appState.deleteComment(postId, commentId);
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }

  Widget _buildSavedPostsList(AppState appState) {
    return FutureBuilder<List<DocumentSnapshot>>(
      future: appState.getSavedPosts(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Center(child: CircularProgressIndicator());
        }
        if (snapshot.hasError) {
          print('Error in _buildSavedPostsList: ${snapshot.error}');
          return Center(child: Text('Error loading saved posts'));
        }
        final savedPosts = snapshot.data ?? [];
        if (savedPosts.isEmpty) {
          return Center(child: Text('No saved posts yet'));
        }
        return ListView.builder(
          itemCount: savedPosts.length,
          itemBuilder: (context, index) {
            final post = savedPosts[index].data() as Map<String, dynamic>?;
            if (post == null) {
              return SizedBox.shrink();
            }
            return FutureBuilder<DocumentSnapshot>(
              future: FirebaseFirestore.instance
                  .collection('users')
                  .doc(post['userId'])
                  .get(),
              builder: (context, userSnapshot) {
                String userName = '@[deleted]';
                String profileEmoji = 'ü´•';
                if (userSnapshot.connectionState == ConnectionState.done &&
                    userSnapshot.hasData) {
                  final userData =
                      userSnapshot.data!.data() as Map<String, dynamic>?;
                  userName = userData?['userName'] as String? ?? '';
                  profileEmoji = userData?['profileEmoji'] as String? ?? 'ü´•';
                  if (userName.isEmpty) {
                    userName = '@[deleted]';
                  } else {
                    userName = '@$userName';
                  }
                }
                return PostCard(
                  title: post['title'] ?? '',
                  content: post['content'] ?? '',
                  commentCount: post['commentCount'] ?? 0,
                  timestamp: post['timestamp']?.toDate() ?? DateTime.now(),
                  postId: savedPosts[index].id,
                  userId: post['userId'] ?? '',
                  profileEmoji: profileEmoji,
                  userName: userName,
                );
              },
            );
          },
        );
      },
    );
  }
}

String getRelativeTime(DateTime dateTime) {
  final now = DateTime.now();
  final difference = now.difference(dateTime);

  if (difference.inSeconds < 60) {
    return 'Now';
  } else if (difference.inMinutes < 60) {
    return '${difference.inMinutes} min';
  } else if (difference.inHours < 24) {
    return '${difference.inHours} hr';
  } else if (difference.inDays < 30) {
    return '${difference.inDays} day${difference.inDays == 1 ? '' : 's'}';
  } else if (difference.inDays < 365) {
    final months = (difference.inDays / 30).floor();
    return '$months month${months == 1 ? '' : 's'}';
  } else {
    final years = (difference.inDays / 365).floor();
    return '$years year${years == 1 ? '' : 's'}';
  }
}

================
File: app/lib/scuttlebutt_app.dart
================
// File: app/lib/scuttlebutt_app.dart

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'home_screen.dart';
import 'profile_screen.dart';
import 'settings_screen.dart';
import 'app_state.dart';

class ScuttleApp extends StatelessWidget {
  const ScuttleApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => AppState(),
      child: MaterialApp(
        theme: ThemeData(
          useMaterial3: true,
          colorSchemeSeed: Colors.blue[800],
          appBarTheme: AppBarTheme(
            backgroundColor: Colors.blue[800],
            foregroundColor: Colors.white,
          ),
          bottomNavigationBarTheme: BottomNavigationBarThemeData(
            selectedItemColor: Colors.blue[800],
            unselectedItemColor: Colors.grey,
          ),
        ),
        home: ScuttleHomePage(),
      ),
    );
  }
}

class ScuttleHomePage extends StatefulWidget {
  const ScuttleHomePage({Key? key}) : super(key: key);

  @override
  _ScuttleHomePageState createState() => _ScuttleHomePageState();
}

class _ScuttleHomePageState extends State<ScuttleHomePage> {
  int _selectedIndex = 0;

  final List<Widget> _widgetOptions = <Widget>[
    const HomeScreen(),
    const ProfileScreen(),
    const SettingsScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _widgetOptions.elementAt(_selectedIndex),
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: 'Home',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person),
            label: 'You',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.settings),
            label: 'Settings',
          ),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: Colors.blue[800],
        unselectedItemColor: Colors.grey,
        onTap: _onItemTapped,
        type: BottomNavigationBarType.fixed,
        showUnselectedLabels: true,
      ),
    );
  }
}

================
File: app/lib/settings_screen.dart
================
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:provider/provider.dart';
import 'app_state.dart';
import 'login_screen.dart';
import 'zone_selection_screen.dart';
import 'privacy_policy_screen.dart';
import 'about_screen.dart';
import 'guidelines_screen.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    return SafeArea(
      child: ListView(
        children: [
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Center(
              child: Text(
                'Settings',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
          _buildSectionHeader('App'),
          ListTile(
            leading: Icon(Icons.info),
            title: Text('About'),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => AboutScreen()),
              );
            },
          ),
          ListTile(
            leading: Icon(Icons.people),
            title: Text('Guidelines'),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => GuidelinesScreen()),
              );
            },
          ),
          ListTile(
            leading: Icon(Icons.privacy_tip),
            title: Text('Privacy policy'),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => PrivacyPolicyScreen()),
              );
            },
          ),
          _buildSectionHeader('Account'),
          ListTile(
            leading: Icon(Icons.location_city),
            title: Text(appState.command == null ? 'Set Zone' : 'Current Zone'),
            subtitle: Text(appState.command ?? 'Not set'),
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                    builder: (context) =>
                        ZoneSelectionScreen(isInitialSetup: false)),
              );
            },
          ),
          ListTile(
            leading: Icon(Icons.exit_to_app),
            title: Text('Log Out'),
            onTap: () async {
              await FirebaseAuth.instance.signOut();
              Provider.of<AppState>(context, listen: false).clearUserData();
              Navigator.of(context).pushAndRemoveUntil(
                MaterialPageRoute(builder: (context) => LoginScreen()),
                (Route<dynamic> route) => false,
              );
            },
          ),
          ListTile(
            leading: Icon(Icons.delete_forever, color: Colors.red),
            title: Text(
              'Delete Account',
              style: TextStyle(color: Colors.red),
            ),
            onTap: () {
              _showDeleteAccountConfirmation(context);
            },
          ),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
      child: Text(
        title,
        style: TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.bold,
          color: Colors.blue[800],
        ),
      ),
    );
  }

  void _showDeleteAccountConfirmation(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text('Delete Account'),
          content: Text(
              'Are you sure you want to delete your account? This action cannot be undone.'),
          actions: <Widget>[
            TextButton(
              child: Text('Cancel'),
              onPressed: () {
                Navigator.of(dialogContext).pop();
              },
            ),
            TextButton(
              child: Text('Delete', style: TextStyle(color: Colors.red)),
              onPressed: () async {
                Navigator.of(dialogContext).pop();
                try {
                  await Provider.of<AppState>(context, listen: false)
                      .deleteAccount();
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Account deleted successfully')),
                  );
                  Navigator.of(context).pushAndRemoveUntil(
                    MaterialPageRoute(builder: (context) => LoginScreen()),
                    (Route<dynamic> route) => false,
                  );
                } catch (e) {
                  print('Error deleting account: $e');
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Failed to delete account: $e')),
                  );
                }
              },
            ),
          ],
        );
      },
    );
  }
}

================
File: app/lib/zone_selection_screen.dart
================
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:geolocator/geolocator.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'app_state.dart';
import 'scuttlebutt_app.dart';

class ZoneSelectionScreen extends StatefulWidget {
  final bool isInitialSetup;

  const ZoneSelectionScreen({Key? key, this.isInitialSetup = true})
      : super(key: key);

  @override
  _ZoneSelectionScreenState createState() => _ZoneSelectionScreenState();
}

class _ZoneSelectionScreenState extends State<ZoneSelectionScreen> {
  String? _recommendedZone;
  bool _isLoading = false;
  bool _isLocationDenied = false;

  @override
  void initState() {
    super.initState();
    _initializeUserAndCheckLocation();
  }

  Future<void> _initializeUserAndCheckLocation() async {
    setState(() => _isLoading = true);

    final appState = Provider.of<AppState>(context, listen: false);
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      await appState.initializeUser(user.uid);
    }

    await _checkAndRequestLocationPermission();

    setState(() => _isLoading = false);
  }

  Future<void> _checkAndRequestLocationPermission() async {
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      setState(() => _isLocationDenied = true);
      return;
    }

    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        setState(() => _isLocationDenied = true);
        return;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      setState(() => _isLocationDenied = true);
      return;
    }

    _checkLocationAndSetZone();
  }

  Future<void> _checkLocationAndSetZone() async {
    try {
      Position position = await Geolocator.getCurrentPosition();
      final appState = Provider.of<AppState>(context, listen: false);
      await appState.setUserLocation(position);
      String? recommendedZone = appState.getRecommendedZone();
      setState(() {
        _recommendedZone = recommendedZone;
        _isLocationDenied = false;
      });
    } catch (e) {
      print('Error getting location: $e');
      setState(() => _isLocationDenied = true);
    }
  }

  Future<void> _setZoneAcknowledged() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('zone_acknowledged', true);
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);

    return WillPopScope(
      onWillPop: () async => !widget.isInitialSetup,
      child: Scaffold(
        appBar: widget.isInitialSetup
            ? null
            : AppBar(
                title: Text('Set Zone'),
              ),
        body: SafeArea(
          child: _isLoading
              ? Center(child: CircularProgressIndicator())
              : Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      SizedBox(height: 20),
                      if (_isLocationDenied)
                        _buildLocationDeniedWidget()
                      else if (_recommendedZone != null)
                        Text(
                          'Recommended zone based on your location: $_recommendedZone',
                          style: TextStyle(
                              fontSize: 18, fontWeight: FontWeight.bold),
                        )
                      else
                        _buildNoZoneWidget(),
                      SizedBox(height: 24),
                      Expanded(
                        child: ListView(
                          children: AppState.zones.keys.map((zone) {
                            bool isRecommended = zone == _recommendedZone;
                            bool isEnabled = _recommendedZone != null;
                            return ListTile(
                              title: Text(zone),
                              enabled: isEnabled,
                              selected: isRecommended,
                              tileColor: isRecommended
                                  ? Colors.blue.withOpacity(0.1)
                                  : null,
                              textColor: isEnabled ? null : Colors.grey,
                            );
                          }).toList(),
                        ),
                      ),
                      SizedBox(height: 16),
                      Center(
                        child: ElevatedButton(
                          child: Text(
                              widget.isInitialSetup ? 'Proceed' : 'Confirm'),
                          onPressed: () async {
                            if (!_isLocationDenied) {
                              await appState.setUserCommand(_recommendedZone);
                            }
                            await _setZoneAcknowledged();
                            if (widget.isInitialSetup) {
                              Navigator.of(context).pushReplacement(
                                MaterialPageRoute(
                                    builder: (context) => ScuttleHomePage()),
                              );
                            } else {
                              Navigator.of(context).pop();
                            }
                          },
                        ),
                      ),
                    ],
                  ),
                ),
        ),
      ),
    );
  }

  Widget _buildLocationDeniedWidget() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Location access is currently denied.',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        SizedBox(height: 8),
        Text(
          'You will only see the main feed. You can grant location permission later in the settings.',
          style: TextStyle(fontSize: 16),
        ),
        SizedBox(height: 16),
        if (!widget.isInitialSetup)
          ElevatedButton(
            child: Text('Open Location Settings'),
            onPressed: () async {
              await Geolocator.openLocationSettings();
              _checkAndRequestLocationPermission();
            },
          ),
      ],
    );
  }

  Widget _buildNoZoneWidget() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'You are not close to any of the zones.',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        SizedBox(height: 8),
        Text(
          'You will only have access to the main feed.',
          style: TextStyle(fontSize: 16),
        ),
      ],
    );
  }
}

================
File: app/pubspec.yaml
================
name: scuttlebutt
description: An anonymous social app for military personnel.

version: 1.0.2+1

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.2
  firebase_core: ^2.13.1
  firebase_auth: ^4.6.2
  cloud_firestore: ^4.8.0
  provider: ^6.0.2
  google_sign_in: ^6.1.0
  geolocator: ^9.0.2 
  shared_preferences: ^2.1.1
  sign_in_with_apple: ^4.3.0
  flutter_webview_plugin: ^0.4.0
  http: ^0.13.5
  cloud_functions: ^4.3.2  # Make sure we only have this one, not firebase_functions
  crypto: ^3.0.1
  flutter_web_auth: ^0.5.0
  image_picker: ^0.8.7+5
  firebase_storage: ^11.2.2
  
dev_dependencies:
  flutter_test:
    sdk: flutter

flutter:
  uses-material-design: true
  assets:
    - assets/

================
File: functions/index.js
================
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const axios = require('axios');

admin.initializeApp();

exports.createFirebaseToken = functions.https.onCall(async (data, context) => {
    console.log('createFirebaseToken function called with data:', JSON.stringify(data));
    const idmeToken = data.idmeToken;

    if (!idmeToken) {
        console.error('ID.me token is missing');
        throw new functions.https.HttpsError('invalid-argument', 'ID.me token is required');
    }

    try {
        console.log('Fetching user data from ID.me');
        const response = await axios.get('https://api.id.me/api/public/v3/attributes.json', {
            headers: {
                'Authorization': `Bearer ${idmeToken}`,
                'Accept': 'application/json'
            }
        });

        console.log('ID.me API Response:', {
            status: response.status,
            data: response.data
        });

        const userData = response.data;

        // Check if we got valid user data
        if (!userData || !userData.attributes) {
            console.error('Invalid user data returned from ID.me:', userData);
            throw new functions.https.HttpsError(
                'internal',
                'Invalid user data returned from ID.me'
            );
        }

        // Find email in attributes
        const emailAttr = userData.attributes.find(attr => attr.handle === 'email');
        if (!emailAttr || !emailAttr.value) {
            throw new functions.https.HttpsError(
                'internal',
                'No email found in ID.me response'
            );
        }

        const email = emailAttr.value;
        console.log('Found user email:', email);

        // Create or update Firebase user
        let firebaseUser;
        try {
            firebaseUser = await admin.auth().getUserByEmail(email);
            console.log('Found existing Firebase user:', firebaseUser.uid);
        } catch (error) {
            if (error.code === 'auth/user-not-found') {
                const fnameAttr = userData.attributes.find(attr => attr.handle === 'fname');
                const lnameAttr = userData.attributes.find(attr => attr.handle === 'lname');

                firebaseUser = await admin.auth().createUser({
                    email: email,
                    emailVerified: true,
                    displayName: `${fnameAttr?.value || ''} ${lnameAttr?.value || ''}`.trim() || undefined
                });
                console.log('Created new Firebase user:', firebaseUser.uid);
            } else {
                console.error('Error getting/creating Firebase user:', error);
                throw new functions.https.HttpsError('internal', error.message);
            }
        }

        // Update custom claims
        await admin.auth().setCustomUserClaims(firebaseUser.uid, {
            idmeVerified: true,
            militaryStatus: 'military'
        });

        // Create custom token
        const customToken = await admin.auth().createCustomToken(firebaseUser.uid);
        console.log('Created custom token for user:', firebaseUser.uid);

        return { customToken };

    } catch (error) {
        console.error('Error in createFirebaseToken:', error);
        if (error.response) {
            console.error('ID.me API error:', {
                status: error.response.status,
                data: error.response.data
            });
        }
        if (error instanceof functions.https.HttpsError) {
            throw error;
        }
        throw new functions.https.HttpsError(
            'internal',
            error.message || 'An unknown error occurred'
        );
    }
});

================
File: firebase.json
================
{
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ]
    }
  ],
  "emulators": {
    "functions": {
      "port": 5001
    },
    "ui": {
      "enabled": true
    },
    "singleProjectMode": true
  }
}

================
File: wm-db.txt
================
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isAppStoreReviewer() {
      return request.auth != null && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAppStoreReviewer == true;
    }

    function isAppStoreReviewerOrAuth() {
      return request.auth != null || isAppStoreReviewer();
    }

    match /users/{userId} {
      allow read: if true;
      allow create: if 
        (request.resource.data.isAppStoreReviewer == true && 
         request.resource.data.userName == '@appstorereview') || 
        (request.auth != null && request.auth.uid == userId);
      allow update: if isAppStoreReviewerOrAuth() &&
                       (request.auth.uid == userId || 
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['points', 'votes', 'commentVotes', 'savedPosts', 'command', 'profileEmoji']));
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    match /posts/{postId} {
      allow read: if true;
      allow create: if isAppStoreReviewerOrAuth();
      allow update: if isAppStoreReviewerOrAuth() &&
                       (resource.data.userId == request.auth.uid || 
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['points', 'commentCount']));
      allow delete: if isAppStoreReviewerOrAuth() && request.auth.uid == resource.data.userId;
    }
    
    match /comments/{commentId} {
      allow read: if true;
      allow create: if isAppStoreReviewerOrAuth();
      allow update: if isAppStoreReviewerOrAuth() &&
                       (resource.data.userId == request.auth.uid || 
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['points']));
      allow delete: if isAppStoreReviewerOrAuth() && request.auth.uid == resource.data.userId;
    }
  }
}
